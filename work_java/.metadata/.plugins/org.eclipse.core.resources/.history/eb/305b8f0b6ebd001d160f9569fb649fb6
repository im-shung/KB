import java.io.*;
import java.util.*;

class Node {
	int R;
	int C;

	public Node(int r, int c) {
		super();
		R = r;
		C = c;
	}

}

public class Main {

	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;

	static int[] DR = { 1, -1, 0, 0 };
	static int[] DC = { 0, 0, 1, -1 };

	static int[][] MAP, BLANK;
	static boolean[][] VISIT;

	static int N, M;
	static int ANSWER;
	static int BLANK_COUNT;

	static void input() throws IOException {
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());

		MAP = new int[N + 1][M + 1];
		BLANK = new int[N + 1][M + 1];
		VISIT = new boolean[N + 1][M + 1];

		for (int R = 1; R <= N; R++) {
			st = new StringTokenizer(br.readLine());
			for (int C = 1; C <= N; C++) {
				MAP[R][C] = Integer.parseInt(st.nextToken());
			}
		}
	}

	// 바이러스 퍼뜨리기!!
	public static void bfs() {

		// 모든 바이러스가 시작점으로 가능하니까, 전부 큐에 넣어준다.

		// BFS 과정

		// 1. 큐에서 꺼냄

		// 2. 목적지인가?
		// 3. 연결된 곳인가?

		// 4. 갈 수 있는가? -> 맵 벗어나면 x, 방문했다면 x, 빈 칸이 아니면 x

		// 5. 체크인
		// 6. 큐에 넣음

		
		// 탐색이 종료된 시점이니, 안전 영역의 넓이를 계산하고, 정답을 갱신한다.
	}



	// idx 번째 빈 칸에 벽을 세울 지 말 지 결정해야 하고, 이 전까지 selected_cnt 개의 벽을 세웠다.
	static void dfs(int idx, int selected_cnt) {
		// 3 개의 벽을 모두 세운 상태

		// 더 이상 세울 수 있는 벽이 없는 상태

	}

	public static void pro() {
		// 모든 벽의 위치를 먼저 모아놓자.
		for (int R = 1; R <= N; R++) {
			for (int C = 1; C <= M; C++) {

			}
		}
		// 벽을 3개 세우는 모든 방법을 확인해보자!

	}

	public static void main(String[] args) throws IOException {
		/* 입력 */
		input();
		/* 처리 */
		pro();
		/* 출력 */
		System.out.println(ANSWER);
	}
}
